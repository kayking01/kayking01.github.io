<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="这是显示在首页的概述，正文内容均会被隐藏。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Zookeeper 更新中 |  Difory</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/rss2.xml" title="Difory" type="application/rss+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-zookeeper"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Zookeeper 更新中
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/16/zookeeper/" class="article-date">
  <time datetime="2024-10-15T16:00:00.000Z" itemprop="datePublished">2024-10-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">6.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">23 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p><strong>ZooKeeper 是一个开源的分布式协调框架</strong>，是Apache Hadoop 的一个子项目，<strong>主要用来解决分布式集群中应用系统的一致性问题</strong>。Zookeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<p><strong>ZooKeeper本质上是一个分布式的小文件存储系统（Zookeeper&#x3D;文件系统+监听机制）</strong>。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到<strong>基于数据的集群管理、统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。</strong></p>
<p><img src="/images/zookeeper/image-20241008103345979.png" alt="image-20241008103345979"></p>
<p>Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p>
<p><img src="/images/zookeeper/image-20241008103702135.png" alt="image-20241008103702135"></p>
<h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><p>官网：<a target="_blank" rel="noopener" href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p>
<p>安装地址：<a target="_blank" rel="noopener" href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p>
<p>指令地址：<a target="_blank" rel="noopener" href="https://zookeeper.apache.org/doc/r3.8.0/zookeeperCLI.html">https://zookeeper.apache.org/doc/r3.8.0/zookeeperCLI.html</a></p>
<h4 id="1、修改配置文件"><a href="#1、修改配置文件" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h4><p>解压安装包后进入conf目录，复制zoo_sample.cfg，修改为zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<p>修改 zoo.cfg 配置文件，将 dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper 修改为指定的data目录</p>
<p><img src="/images/zookeeper/image-20241008105001526.png" alt="image-20241008105001526"></p>
<h4 id="2、启动服务"><a href="#2、启动服务" class="headerlink" title="2、启动服务"></a>2、启动服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以通过 bin/zkServer.sh 来查看都支持哪些参数1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认加载配置路径conf/zoo.cfg2</span></span><br><span class="line"></span><br><span class="line">输入命令 help 查看zookeeper支持的所有命令：</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line">bin/zkServer.sh start conf/my_zoo.cfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看zookeeper状态</span></span><br><span class="line">bin/zkServer.sh status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############</span></span></span><br><span class="line">yum install -y  java-1.8.0-openjdk-devel.x86_64</span><br><span class="line"></span><br><span class="line">安装openjdk-devel包</span><br><span class="line">使用 jps 查看所有java虚拟机进程</span><br></pre></td></tr></table></figure>

<h4 id="3、客户端连接服务"><a href="#3、客户端连接服务" class="headerlink" title="3、客户端连接服务"></a>3、客户端连接服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/zkCli.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接远程的zookeeper server</span></span><br><span class="line">bin/zkCli.sh -server ip:port</span><br></pre></td></tr></table></figure>

<p>常用cli命令 <a target="_blank" rel="noopener" href="https://zookeeper.apache.org/doc/r3.8.0/zookeeperCLI.html">https://zookeeper.apache.org/doc/r3.8.0/zookeeperCLI.html</a></p>
<table>
<thead>
<tr>
<th>命令基本语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>help</td>
<td>显示所有操作命令</td>
</tr>
<tr>
<td>ls [-s] [-w] [-R] path</td>
<td>使用 ls 命令来查看当前 znode 的子节点 [可监听]<br />-w: 监听子节点变化（一次性的）<br /> -s: 节点状态信息（时间戳、版本号、数据大小等）<br />-R: 表示递归的获取</td>
</tr>
<tr>
<td>create [-s] [-e] [-c] [-t ttl] path [data] [acl]</td>
<td>创建节点<br/>-s : 创建有序节点。<br/>-e : 创建临时节点。<br/>-c : 创建一个容器节点。<br/>-t ttl : 创建一个TTL节点， -t 时间（单位毫<br/>秒）。<br/>data：节点的数据，可选，如果不使用时，节点<br/>数据就为null。<br/>acl：访问控制</td>
</tr>
<tr>
<td>get [-s] [-w] path</td>
<td>获取节点数据信息<br/>-s: 节点状态信息（时间戳、版本号、数据大小<br/>等）<br/>-w: 监听节点变化（一次性的）</td>
</tr>
<tr>
<td>set [-s] [-v version] path data</td>
<td>设置节点数据<br/>-s:表示节点为顺序节点<br/>-v: 指定版本号</td>
</tr>
<tr>
<td>getAcl [-s] path</td>
<td>获取节点的访问控制信息<br/>-s: 节点状态信息（时间戳、版本号、数据大小<br/>等）</td>
</tr>
<tr>
<td>setAcl [-s] [-v version] [-R] path acl</td>
<td>设置节点的访问控制列表<br/>-s:节点状态信息（时间戳、版本号、数据大小<br/>等）<br/>-v:指定版本号<br/>-R:递归的设置</td>
</tr>
<tr>
<td>stat [-w] path</td>
<td>查看节点状态信息</td>
</tr>
<tr>
<td>delete [-v version] path</td>
<td>删除某一节点，只能删除无子节点的节点。<br/>-v： 表示节点版本号</td>
</tr>
<tr>
<td>deleteall path</td>
<td>递归的删除某一节点及其子节点</td>
</tr>
<tr>
<td>setquota -n| -b val path</td>
<td>对节点增加限制<br/>n:表示子节点的最大个数<br/>b:数据值的最大长度，-1表示无限制</td>
</tr>
</tbody></table>
<h4 id="4、GUI工具"><a href="#4、GUI工具" class="headerlink" title="4、GUI工具"></a>4、GUI工具</h4><p>Zookeeper图形化工具：<a target="_blank" rel="noopener" href="https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip">ZooInspector</a><br>Zookeeper图形化工具：开源的<a target="_blank" rel="noopener" href="https://github.com/vran-dev/PrettyZoo/releases">prettyZoo</a><br>Zookeeper图形化工具：收费的<a target="_blank" rel="noopener" href="http://www.redisant.cn/za">ZooKeeperAssistant</a></p>
<h3 id="三、ZooKeeper数据结构"><a href="#三、ZooKeeper数据结构" class="headerlink" title="三、ZooKeeper数据结构"></a>三、ZooKeeper数据结构</h3><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。</p>
<p>ZooKeeper的数据模型是层次模型，层次模型常见于文件系统。层次模型和key-value模型是两种主流的数据模型。ZooKeeper使用文件系统模型主要基于以下两点考虑：</p>
<ol>
<li>文件系统的树形结构便于表达数据之间的层次关系。</li>
<li>文件系统的树形结构便于为不同的应用分配独立的命名空间( namespace )。</li>
</ol>
<p>ZooKeeper的层次模型称作Data Tree，Data Tree的每个节点叫作Znode。不同于文件系统，每个节点都可以保存数据，每一个 ZNode 默认能够存储 <strong>1MB</strong> 的数据，每个 ZNode 都可以通过其路径唯一标识，每个节点都有一个版本(version)，版本从0开始计数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes =</span><br><span class="line">        						<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, DataNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WatchManager</span> <span class="variable">dataWatches</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchManager</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WatchManager</span> <span class="variable">childWatches</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchManager</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataNode</span> <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="type">byte</span> data[];</span><br><span class="line">    Long acl;</span><br><span class="line">    <span class="keyword">public</span> StatPersisted stat;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; children = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、节点分类"><a href="#1、节点分类" class="headerlink" title="1、节点分类"></a>1、节点分类</h4><p>zookeeper存在几种不同的节点类型，他们具有不同的生命周期：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>生命周期</th>
<th>创建示例</th>
</tr>
</thead>
<tbody><tr>
<td>持久节点 （persistent node)</td>
<td>一直存在，一直存储在ZooKeeper 服务器上<br/>即使创建该节点的客户端与服务端的会话关闭了，<br/>该节点依然不会被删</td>
<td>create &#x2F;locks</td>
</tr>
<tr>
<td>临时节点 (ephemeral node）</td>
<td>当创建该临时节点的客户端会话因超时或发生异常<br />而关闭时，该节点也相应在 ZooKeeper 服务<br/>器上被删除。临时节点无法创建子节点</td>
<td>create -e &#x2F;locks&#x2F;DBLock</td>
</tr>
<tr>
<td>有序节点 (sequential node)</td>
<td>并不算是一种单独种类的节点，而是在之前提到的<br />持久节点和临时节点特性的基础上，增加了一个节点有序的性质。<br />在我们创建有序节点的时候会自动使用一个单调递增的数字作为后缀。</td>
<td>create -e -s &#x2F;jobs&#x2F;job<br />(有序临时节点)</td>
</tr>
<tr>
<td>容器节点 (container node)</td>
<td>当一个容器节点的最后一个子节<br/>点被删除后，容器节点也会被删<br/>除</td>
<td>create -c &#x2F;work</td>
</tr>
<tr>
<td>TTL节点 (ttl node)</td>
<td>当一个TTL节点在 TTL 内没有被<br/>修改并且没有子节点，会被删<br/>除。注意：默认此功能不开启，<br/>需要修改配置文件<br/>extendedTypesEnabled&#x3D;true</td>
<td>create -t 3000 &#x2F;ttl_node</td>
</tr>
</tbody></table>
<p>一个znode可以使持久性的，也可以是临时性的：</p>
<ol>
<li>持久节点(PERSISTENT): 这样的znode在创建之后即使发生ZooKeeper集群宕机或者client宕机<br>也不会丢失。</li>
<li>临时节点(EPHEMERAL ): client宕机或者client在指定的timeout时间内没有给ZooKeeper集群<br>发消息，这样的znode就会消失。<br>如果上面两种znode具备顺序性，又有以下两种znode :</li>
<li>持久顺序节点(PERSISTENT_SEQUENTIAL): znode除了具备持久性znode的特点之外，znode<br>的名字具备顺序性。</li>
<li>临时顺序节点(EPHEMERAL_SEQUENTIAL): znode除了具备临时性znode的特点之外，zorde<br>的名字具备顺序性。<br>zookeeper主要用到的是以上4种节点。</li>
<li>Container节点 (3.5.3版本新增)：Container容器节点，当容器中没有任何子节点，该容器节点<br>会被zk定期删除（定时任务默认60s 检查一次)。 和持久节点的区别是 ZK 服务端启动后，会有一个单<br>独的线程去扫描，所有的容器节点，当发现容器节点的子节点数量为 0 时，会自动删除该节点。可以<br>用于 leader 或者锁的场景中。</li>
<li>TTL节点: 带过期时间节点，默认禁用，需要在zoo.cfg中添加 extendedTypesEnabled&#x3D;true 开<br>启。 注意：TTL不能用于临时节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建持久节点1</span></span><br><span class="line">create /servers xxx2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建临时节点3</span></span><br><span class="line">create -e /servers/host xxx4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建临时有序节点5</span></span><br><span class="line">create -e -s /servers/host xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建容器节点7</span></span><br><span class="line">create -c /container xxx8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建ttl节点9</span></span><br><span class="line">create -t 10 /ttl</span><br></pre></td></tr></table></figure>

<h4 id="2、节点状态信息"><a href="#2、节点状态信息" class="headerlink" title="2、节点状态信息"></a>2、节点状态信息</h4><p>类似于树状结构，节点下面是可以存储一些信息和属性的。可以通过stat命令来进行查看。</p>
<ul>
<li>cZxid ：Znode创建的事务id。</li>
<li>ctime：节点创建时的时间戳。</li>
<li>mZxid ：Znode被修改的事务id，即每次对znode的修改都会更新mZxid。</li>
</ul>
<p>对于zk来说，每次的变化都会产生一个唯一的事务id，zxid（ZooKeeper Transaction Id），通过zxid，可以确定更新操作的先后顺序。例如，如果zxid1小于zxid2，说明zxid1操作先于zxid2发生，zxid对于整个zk都是唯一的，即使操作的是不同的znode。</p>
<ul>
<li>pZxid: 表示该节点的子节点列表最后一次修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该ID（注意: 只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响pzxid ）</li>
<li>mtime：节点最新一次更新发生时的时间戳.</li>
<li>cversion ：子节点的版本号。当znode的子节点有变化时，cversion 的值就会增加1。</li>
<li>dataVersion：数据版本号，每次对节点进行set操作，dataVersion的值都会增加1（即使设置的是相同的数据），可有效避免了数据更新时出现的先后顺序问题。</li>
<li>ephemeralOwner:如果该节点为临时节点, ephemeralOwner值表示与该节点绑定的session id。如果不是，ephemeralOwner值为0(持久节点)</li>
<li>dataLength ： 数据的长度</li>
<li>numChildren ：子节点的数量（只统计直接子节点的数量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在client和server通信之前,首先需要建立连接,该连接称为session。连接建立后,如果发生连接超时、授权失败,或者显式关闭连接,连接便处于closed状态, 此时session结束。</span><br></pre></td></tr></table></figure>


<h4 id="3、监听机制详解"><a href="#3、监听机制详解" class="headerlink" title="3、监听机制详解"></a>3、监听机制详解</h4><h5 id="3-1临时性watch"><a href="#3-1临时性watch" class="headerlink" title="3.1临时性watch"></a>3.1临时性watch</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch机制，顾名思义是一个监听机制。Zookeeper中的watch机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</span><br></pre></td></tr></table></figure>


<p>监听的对象是事件，支持的事件类型如下：</p>
<ul>
<li>None: 连接建立事件</li>
<li>NodeCreated： 节点创建</li>
<li>NodeDeleted： 节点删除</li>
<li>NodeDataChanged：节点数据变化</li>
<li>NodeChildrenChanged：子节点列表变化</li>
<li>DataWatchRemoved：节点监听被移除</li>
<li>ChildWatchRemoved：子节点监听被移除</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">监听节点数据的变化</span></span><br><span class="line">get -w path</span><br><span class="line">stat -w path</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">监听子节点增减的变化</span></span><br><span class="line">ls -w path</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>一次性触发</td>
<td>watch是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td>
</tr>
<tr>
<td>客户端顺序回调</td>
<td>watch回调是顺序串行执行的，只有回调后客户端才能看到最新的数据状态。<br />一个watcher回调逻辑不应该太多，以免影响别的watch执行</td>
</tr>
<tr>
<td>轻量级</td>
<td>WatchEvent是最小的通信单位，结构上只包含通知状态、事件类型和节点路径，<br />并不会告诉数据节点变化前后的具体内容</td>
</tr>
<tr>
<td>时效性</td>
<td>watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，<br />则watcher依然存在，仍可接收到通知；</td>
</tr>
</tbody></table>
<h5 id="3-2-永久性Watch"><a href="#3-2-永久性Watch" class="headerlink" title="3.2 永久性Watch"></a>3.2 永久性Watch</h5><p>在被触发之后，仍然保留，可以继续监听ZNode上的变更，是<strong>Zookeeper 3.6.0</strong>版本新增的功能</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addWatch [-m mode] path</span><br></pre></td></tr></table></figure>

<p>addWatch的作用是针对指定节点添加事件监听，支持两种模式：</p>
<ul>
<li><p>PERSISTENT，持久化订阅，针对当前节点的修改和删除事件，以及当前节点的子节点的删除和新增事件。</p>
</li>
<li><p>PERSISTENT_RECURSIVE，持久化递归订阅(默认)，在PERSISTENT的基础上，增加了子节点修改的事件触发，</p>
<p>以及子节点的子节点的数据变化都会触发相关事件（满足递归订阅特性）</p>
</li>
</ul>
<h6 id="示例-协同服务"><a href="#示例-协同服务" class="headerlink" title="示例: 协同服务"></a>示例: 协同服务</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设计一个master-worker的组成员管理系统，要求系统中只能有一个master , master能实时获取系统中worker的情况。保证组里面只有一个master的设计思路。</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">master1</span></span><br><span class="line">create -e /master &quot;m1:2223&quot;  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">master2</span></span><br><span class="line">create -e /master &quot;m2:2223&quot;   # /master已经存在，创建失败</span><br><span class="line">Node already exists: /master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">监听/master节点</span></span><br><span class="line">stat -w /master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当master2收到/master节点删除通知后可以再次发起创建节点操作</span></span><br><span class="line">create -e /master &quot;m2:2223&quot; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master-slave选举也可以用这种方式：</span><br></pre></td></tr></table></figure>


<p><img src="/images/zookeeper/image-20241008165335770.png" alt="image-20241008165335770"></p>
<p>master监控worker状态的设计思路：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">master服务</span></span><br><span class="line">create /workers</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让master服务监控/workers下的子节点</span></span><br><span class="line">ls -w /workers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">worker1</span></span><br><span class="line">create -e /workers/w1 &quot;w1:2224&quot; #创建子节点，master服务会收到子节点变化通知</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">master服务</span></span><br><span class="line">ls -w /workers</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">worker2</span></span><br><span class="line">create -e /workers/w2 &quot;w2:2224&quot;  #创建子节点，master服务会收到子节点变化通知</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">master服务</span></span><br><span class="line">ls -w /workers</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">worker2</span></span><br><span class="line">quit  #worker2退出，master服务会收到子节点变化通知</span><br></pre></td></tr></table></figure>

<h6 id="示例：条件更新"><a href="#示例：条件更新" class="headerlink" title="示例：条件更新"></a>示例：条件更新</h6><p>设想用znode &#x2F;c实现一个counter，使用set命令来实现自增1操作。条件更新场景∶</p>
<ol>
<li>客户端1把&#x2F;c更新到版本1，实现&#x2F;c的自增1。</li>
<li>客户端2把&#x2F;c更新到版本2，实现&#x2F;c的自增1。</li>
<li>客户端1不知道&#x2F;c已经被客户端⒉更新过了，还用过时的版本1是去更新&#x2F;c，更新失败。如果客户端1使用的是无条件更新，&#x2F;c就会更新为2，没有实现自增1。</li>
</ol>
<p>使用条件更新可以避免出现客户端基于过期的数据进行数据更新的操作。</p>
<p><img src="/images/zookeeper/image-20241008170916756.png" alt="image-20241008170916756"></p>
<h4 id="4、-节点特性总结"><a href="#4、-节点特性总结" class="headerlink" title="4、 节点特性总结"></a>4、 节点特性总结</h4><ol>
<li><p>同一级节点 key 名称是唯一的</p>
</li>
<li><p>创建节点时，必须要带上全路径</p>
</li>
<li><p>session 关闭，临时节点清除</p>
</li>
<li><p>自动创建顺序节点</p>
<p><img src="/images/zookeeper/image-20241008171022966.png" alt="image-20241008171022966"></p>
</li>
<li><p>watch 机制，监听节点变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件监听机制类似于观察者模式，watch 流程是客户端向服务端某个节点路径上注册一个 watcher，同时客户端也会存储特定的 watcher，当节点数据或子节点发生变化时，服务端通知客户端，客户端进行回调处理。特别注意：-w 的监听事件被单次触发后，事件就失效了。</span><br></pre></td></tr></table></figure></li>
<li><p>delete 命令只能一层一层删除。提示：新版本可以通过 deleteall 命令递归删除。</p>
</li>
</ol>
<h4 id="5、应用场景详解"><a href="#5、应用场景详解" class="headerlink" title="5、应用场景详解"></a>5、应用场景详解</h4><p>ZooKeeper适用于存储和协同相关的关键数据，不适合用于大数据量存储。</p>
<p>有了上述众多节点特性，使得 zookeeper 能开发不出不同的经典应用场景，比如：</p>
<ul>
<li>注册中心</li>
<li>数据发布&#x2F;订阅（常用于实现配置中心）</li>
<li>负载均衡</li>
<li>命名服务</li>
<li>分布式协调&#x2F;通知</li>
<li>集群管理</li>
<li>Master选举</li>
<li>分布式锁</li>
<li>分布式队列</li>
</ul>
<h5 id="5-1-统一命名服务"><a href="#5-1-统一命名服务" class="headerlink" title="5.1 统一命名服务"></a>5.1 统一命名服务</h5><p>在分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别。</p>
<p>例如：IP不容易记住，而域名容易记住。</p>
<p><img src="/images/zookeeper/image-20241008171654251.png" alt="image-20241008171654251"></p>
<p>利用 ZooKeeper 顺序节点的特性，制作分布式的序列号生成器，或者叫 id 生成器。（分布式环境下使用作为数据库 id，另外一种是 UUID（缺点：没有规律）），ZooKeeper 可以生成有顺序的容易理解的同时支持分布式环境的编号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 20] ls -R /jobs</span><br><span class="line">/jobs</span><br><span class="line">/jobs/job0000000006</span><br><span class="line">/jobs/job0000000007</span><br></pre></td></tr></table></figure>

<h5 id="5-2-数据发布-订阅"><a href="#5-2-数据发布-订阅" class="headerlink" title="5.2 数据发布&#x2F;订阅"></a>5.2 数据发布&#x2F;订阅</h5><p>数据发布&#x2F;订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper 的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。</p>
<p>配置信息一般有几个特点:</p>
<ol>
<li>数据量小的KV</li>
<li>数据内容在运行时会发生动态变化</li>
<li>集群机器共享，配置一致</li>
</ol>
<p>ZooKeeper 采用的是推拉结合的方式。</p>
<ol>
<li>推: 服务端会推给注册了监控节点的客户端 Watcher 事件通知</li>
<li>拉: 客户端获得通知后，然后主动到服务端拉取最新的数据</li>
</ol>
<p><img src="/images/zookeeper/image-20241008172002579.png" alt="image-20241008172002579"></p>
<h5 id="5-3-统一集群管理"><a href="#5-3-统一集群管理" class="headerlink" title="5.3 统一集群管理"></a>5.3 统一集群管理</h5><p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。</p>
<p>ZooKeeper可以实现实时监控节点状态变化：</p>
<ul>
<li>可将节点信息写入ZooKeeper上的一个ZNode。</li>
<li>监听这个ZNode可获取它的实时状态变化。</li>
</ul>
<p><img src="/images/zookeeper/image-20241008172051917.png" alt="image-20241008172051917"></p>
<h5 id="5-4-负载均衡"><a href="#5-4-负载均衡" class="headerlink" title="5.4 负载均衡"></a>5.4 负载均衡</h5><p>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</p>
<p><img src="/images/zookeeper/image-20241008172125648.png" alt="image-20241008172125648"></p>
<h5 id="5-5-Master-Worker架构"><a href="#5-5-Master-Worker架构" class="headerlink" title="5.5 Master-Worker架构"></a>5.5 Master-Worker架构</h5><p>master-work是一个广泛使用的分布式架构。 master-work架构中有一个master负责监控worker的状态，并为worker分配任务。</p>
<ul>
<li>在任何时刻，系统中最多只能有一个master，不可以出现两个master的情况，多个master共存会导致脑裂。</li>
<li>系统中除了处于active状态的master还有一个backup master，如果active master失败了，backup master可以很快的进入active状态。</li>
<li>master实时监控worker的状态，能够及时收到worker成员变化的通知。master在收到worker成员变化的时候，通常重新进行任务的重新分配。</li>
</ul>
<p><img src="/images/zookeeper/image-20241008172207792.png" alt="image-20241008172207792"></p>
<h4 id="6、ACL权限控制"><a href="#6、ACL权限控制" class="headerlink" title="6、ACL权限控制"></a>6、ACL权限控制</h4><p>zookeeper 的 ACL（Access Control List，访问控制表）权限在生产环境是特别重要的，ACL 权限可以针对节点设置相关读写等权限，保障数据安全性。</p>
<p>zookeeper 的 acl 通过 [scheme:id:permissions]来构成权限列表。</p>
<ul>
<li><strong>scheme</strong>：授权的模式，代表采用的某种权限机制，包括 world、auth、digest、ip、super 几种。</li>
<li><strong>id</strong>：授权对象，代表允许访问的用户。如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。如果是 World 模式，是授权系统中所有的用户。</li>
<li><strong>permissions</strong>：授权的权限，权限组合字符串，由 cdrwa 组成，其中每个字母代表支持不同权限， 创建权限 create(c)、删除权限 delete(d)、读权限 read(r)、写权限 write(w)、管理权限admin(a)。</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>world</td>
<td>授权对象只有一个anyone，代表登录到服务器的所有客户端都能对该节点执行某种权限</td>
</tr>
<tr>
<td>ip</td>
<td>对连接的客户端使用IP地址认证方式进行认证</td>
</tr>
<tr>
<td>auth</td>
<td>使用以添加认证的用户进行认证</td>
</tr>
<tr>
<td>digest</td>
<td>使用 用户:密码方式验证</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>权限类型</th>
<th>ACL简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>read</td>
<td>r</td>
<td>读取节点及显示子节点列表的权限</td>
</tr>
<tr>
<td>write</td>
<td>w</td>
<td>设置节点数据的权限</td>
</tr>
<tr>
<td>create</td>
<td>c</td>
<td>创建子节点的权限</td>
</tr>
<tr>
<td>delete</td>
<td>d</td>
<td>删除子节点的权限</td>
</tr>
<tr>
<td>admin</td>
<td>a</td>
<td>设置该节点ACL权限的权限</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>授权命令</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getAcl</td>
<td>getAcl path</td>
<td>读取节点的ACL</td>
</tr>
<tr>
<td>setAcl</td>
<td>setAcl path acl</td>
<td>设置节点的ACL</td>
</tr>
<tr>
<td>create</td>
<td>create path data acl</td>
<td>创建节点时设置acl</td>
</tr>
<tr>
<td>addAuth</td>
<td>addAuth scheme auth</td>
<td>添加认证用户，类似于登录操作</td>
</tr>
</tbody></table>
<p><strong>测试</strong>: 取消节点的读权限后，读取&#x2F;jobs节点没有权限</p>
<p><img src="/images/zookeeper/image-20241008174107633.png" alt="image-20241008174107633"></p>
<h5 id="6-1-auth授权模式"><a href="#6-1-auth授权模式" class="headerlink" title="6.1 auth授权模式"></a>6.1 auth授权模式</h5><p>创建用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addauth digest wk:123456                 # 增加一个认证用户</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次会话（终端）可以增加多个认证用户</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setAcl /name auth:fox:123456:cdrwa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加密 生成密文密码</span></span><br><span class="line">echo -n fox:123456 | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line"></span><br><span class="line">setAcl /name auth:fox:ZsWwgmtnTnx1usRF1voHFJAYGQU=:cdrwa</span><br></pre></td></tr></table></figure>

<p>退出客户端，重新连接之后获取&#x2F;name会没权限，需要添加授权用户。</p>
<h5 id="6-2-digest授权模式"><a href="#6-2-digest授权模式" class="headerlink" title="6.2 digest授权模式"></a>6.2 digest授权模式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置权限</span></span><br><span class="line">setAcl /tuling/fox digest:fox:ZsWwgmtnTnx1usRF1voHFJAYGQU=:cdrwa</span><br></pre></td></tr></table></figure>

<p><img src="/images/zookeeper/image-20241010173511960.png" alt="image-20241010173511960"></p>
<h5 id="6-3-IP授权模式"><a href="#6-3-IP授权模式" class="headerlink" title="6.3 IP授权模式"></a>6.3 IP授权模式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setAcl /node-ip ip:192.168.109.128:cdwra</span><br><span class="line">create /node-ip  data  ip:192.168.109.128:cdwra</span><br></pre></td></tr></table></figure>

<p>多个指定IP可以通过逗号分隔， 如 setAcl &#x2F;node-ip  ip:IP1:rw,ip:IP2:a</p>
<h5 id="6-4-Super-超级管理员模式"><a href="#6-4-Super-超级管理员模式" class="headerlink" title="6.4 Super 超级管理员模式"></a>6.4 Super 超级管理员模式</h5><p>这是一种特殊的Digest模式， 在Super模式下超级管理员用户可以对Zookeeper上的节点进行任何的操作。</p>
<p>需要在启动脚本上通过添加JVM 参数开启：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DigestAuthenticationProvider中定义</span></span><br><span class="line">-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:&lt;base64encoded(SHA1(123456))</span><br></pre></td></tr></table></figure>

<h5 id="6-5-可插拔身份验证接口"><a href="#6-5-可插拔身份验证接口" class="headerlink" title="6.5 可插拔身份验证接口"></a>6.5 可插拔身份验证接口</h5><p>ZooKeeper提供了一种权限扩展机制来让用户实现自己的权限控制方式。</p>
<p>要想实现自定义的权限控制机制，需要继承接口AuthenticationProvider，用户通过该接口实现自定义的权限控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line">    <span class="comment">// 返回标识插件的字符串</span></span><br><span class="line">    String <span class="title function_">getScheme</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 将用户和验证信息关联起来</span></span><br><span class="line">    KeeperException.Code <span class="title function_">handleAuthentication</span><span class="params">(ServerCnxn cnxn, <span class="type">byte</span> authData[])</span>;</span><br><span class="line">    <span class="comment">// 验证id格式</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String id)</span>;</span><br><span class="line">    <span class="comment">// 将认证信息与ACL进行匹配看是否命中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String id, String aclExpr)</span>;</span><br><span class="line">    <span class="comment">// 是否授权</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-6详细解析-auth-和-digest"><a href="#6-6详细解析-auth-和-digest" class="headerlink" title="6.6详细解析 auth 和 digest"></a>6.6详细解析 auth 和 digest</h5><h6 id="6-6-1-auth"><a href="#6-6-1-auth" class="headerlink" title="6.6.1 auth"></a>6.6.1 auth</h6><p><img src="/images/zookeeper/image-20241010195517934.png" alt="image-20241010195517934"></p>
<p>新的会话，需要addauth之后才可以查看auth下的节点，以及setAcl （认证的哪个用户，设置哪个用户）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">auth 不需要指明 <span class="built_in">id</span>     scheme:<span class="built_in">id</span>:permissions</span></span><br><span class="line">create /test2 data auth::crdwa      # 创建 node时赋予 acl</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代表 已认证的 用户有这些权限，再认证新用户就没有这个权限了</span></span><br></pre></td></tr></table></figure>

<h6 id="6-6-2-digest"><a href="#6-6-2-digest" class="headerlink" title="6.6.2 digest"></a>6.6.2 digest</h6><p><img src="/images/zookeeper/image-20241010210341338.png" alt="image-20241010210341338"></p>
<p>注意：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加密 生成密文密码</span></span><br><span class="line">echo -n wkx:123456 | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line"></span><br><span class="line">B16sPINmpfpVvdPV34z4oZylfN0=</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create /test6 data digest:wkx:B16sPINmpfpVvdPV34z4oZylfN0=:crdwa</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>密文密码是账密一起加密的结果。</p>
<h3 id="四、-Zookeeper集群架构"><a href="#四、-Zookeeper集群架构" class="headerlink" title="四、 Zookeeper集群架构"></a>四、 Zookeeper集群架构</h3><h4 id="1-集群角色"><a href="#1-集群角色" class="headerlink" title="1.集群角色"></a>1.集群角色</h4><ul>
<li>Leader： 领导者</li>
</ul>
<p>事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性；集群内部各个服务器的调度者。对于create、setData、delete等有写操作的请求，则要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为事务。</p>
<ul>
<li>Follower: 跟随者</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理客户端非事务（读操作）请求（可以直接响应），转发事务请求给Leader；参与集群Leader选举投票。</span><br></pre></td></tr></table></figure>


<ul>
<li>Observer: 观察者</li>
</ul>
<p>对于非事务请求可以独立处理（读操作），对于事务性请求会转发给leader处理。Observer节点接收来自leader的inform信息，更新自己的本地存储，不参与提交和选举投票。通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置一个ID为3的观察者节点：</span></span><br><span class="line">server.3=192.168.0.3:2888:3888:observer</span><br></pre></td></tr></table></figure>

<p>Observer应用场景：</p>
<ul>
<li>提升集群的读性能。因为Observer和不参与提交和选举的投票过程，所以可以通过往集群里面添加observer节点来提高整个集群的读性能。</li>
<li>跨数据中心部署。 比如需要部署一个北京和香港两地都可以使用的zookeeper集群服务，并且要求北京和香港客户的读请求延迟都很低。解决方案就是把香港的节点都设置为observer。</li>
</ul>
<h4 id="2-集群架构"><a href="#2-集群架构" class="headerlink" title="2.集群架构"></a>2.集群架构</h4><p><img src="/images/zookeeper/image-20241010170936508.png" alt="image-20241010170936508"></p>
<p>leader节点可以处理读写请求，follower只可以处理读请求。follower在接到写请求时会把写请求转发给leader来处理。</p>
<p>Zookeeper数据一致性保证：</p>
<ul>
<li>全局可线性化(Linearizable )写入∶先到达leader的写请求会被先处理，leader决定写请求的执行顺序。</li>
<li>客户端FIFO顺序∶来自给定客户端的请求按照发送顺序执行。</li>
</ul>
<h4 id="3-集群搭建"><a href="#3-集群搭建" class="headerlink" title="3.集群搭建"></a>3.集群搭建</h4><p>环境准备：三台虚拟机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.80</span><span class="number">.110</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.80</span><span class="number">.111</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.80</span><span class="number">.112</span></span><br></pre></td></tr></table></figure>

<p>条件有限也可以在一台虚拟机上搭建zookeeper伪集群</p>
<ol>
<li>修改zoo.cfg配置，添加server节点配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 修改数据存储目录</span><br><span class="line">dataDir=/home/kay/data/zookeeper</span><br><span class="line"></span><br><span class="line">#三台虚拟机 zoo.cfg 文件末尾添加配置</span><br><span class="line">server<span class="number">.1</span>=<span class="number">192.168</span><span class="number">.80</span><span class="number">.110</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server<span class="number">.2</span>=<span class="number">192.168</span><span class="number">.80</span><span class="number">.111</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server<span class="number">.3</span>=<span class="number">192.168</span><span class="number">.80</span><span class="number">.112</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>server.A&#x3D;B:C:D</p>
<p>A 是一个数字，表示这个是第几号服务器； 集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据 就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个server。</p>
<p>B 是这个服务器的地址；</p>
<p>C 是这个服务器Follower与集群中的Leader服务器交换信息的端口；</p>
<p>D 是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p>
</blockquote>
<ol start="2">
<li>创建 myid 文件，配置服务器编号</li>
</ol>
<p>在dataDir对应目录下创建 myid 文件，内容为对应ip的zookeeper服务器编号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/kay/data/zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格）</span></span><br><span class="line">vim myid</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动zookeeper server集群</li>
</ol>
<p>启动前需要关闭防火墙(生产环境需要打开对应端口)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别启动三个节点的zookeeper server  全部启动之后 再查看状态</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群状态</span></span><br><span class="line">bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<h4 id="4、zookeeper选举原理"><a href="#4、zookeeper选举原理" class="headerlink" title="4、zookeeper选举原理"></a>4、zookeeper选举原理</h4><p><strong>第一次启动</strong></p>
<p><img src="/images/zookeeper/image-20241012112252895.png" alt="image-20241012112252895"></p>
<p><strong>非第一次启动</strong></p>
<p><img src="/images/zookeeper/image-20241012165255696.png" alt="image-20241012165255696"></p>
<h4 id="5、写数据原理"><a href="#5、写数据原理" class="headerlink" title="5、写数据原理"></a>5、写数据原理</h4><p>5.1 写流程之写入请求直接发送给Leader节点</p>
<p><img src="/images/zookeeper/image-20241012161813967.png" alt="image-20241012161813967"></p>
<p>5.2 写流程之写入请求直接发送给follower节点</p>
<p><img src="/images/zookeeper/image-20241012161923133.png" alt="image-20241012161923133"></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/10/16/zookeeper/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/10/17/HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            HEXO博客搭建
          
        </div>
      </a>
    
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: "https://twikoojsvercel-lgnqwc1hk-diforys-projects.vercel.app"
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> wang kx
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Difory"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/rss2.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>感谢投喂！</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>